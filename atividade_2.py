# -*- coding: utf-8 -*-
"""code2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X1EL_ndLVSQhpeCEsdUn-6BQaB7zIgwl
"""

import random
from graphviz import Digraph
from IPython.display import display
from graphviz import Source

class Node:
    def __init__(self, valor):
        self.valor = valor
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, valor):
        def _insert(node, valor):
            if not node:
                return Node(valor)
            if valor < node.valor:
                node.left = _insert(node.left, valor)
            elif valor > node.valor:
                node.right = _insert(node.right, valor)
            return node
        self.root = _insert(self.root, valor)

    def search(self, valor):
        def _search(node, valor):
            if not node:
                return None
            if valor == node.valor:
                return node
            elif valor < node.valor:
                return _search(node.left, valor)
            else:
                return _search(node.right, valor)
        return _search(self.root, valor)

    def delete(self, valor):
        def _delete(node, valor):
            if not node:
                return None
            if valor < node.valor:
                node.left = _delete(node.left, valor)
            elif valor > node.valor:
                node.right = _delete(node.right, valor)
            else:
                if not node.left:
                    return node.right
                elif not node.right:
                    return node.left
                temp = self._min_value_node(node.right)
                node.valor = temp.valor
                node.right = _delete(node.right, temp.valor)
            return node
        self.root = _delete(self.root, valor)

    def _min_value_node(self, node):
        current = node
        while current.left:
            current = current.left
        return current

    def height(self):
        def _height(node):
            if not node:
                return -1
            return 1 + max(_height(node.left), _height(node.right))
        return _height(self.root)

    def depth(self, valor):
        def _depth(node, valor, current_depth=0):
            if not node:
                return -1
            if valor == node.valor:
                return current_depth
            elif valor < node.valor:
                return _depth(node.left, valor, current_depth + 1)
            else:
                return _depth(node.right, valor, current_depth + 1)
        return _depth(self.root, valor)

    def visualize(self):
        dot = Digraph()
        def _add_nodes_edges(node):
            if node:
                dot.node(str(id(node)), str(node.valor))
                if node.left:
                    dot.edge(str(id(node)), str(id(node.left)))
                    _add_nodes_edges(node.left)
                if node.right:
                    dot.edge(str(id(node)), str(id(node.right)))
                    _add_nodes_edges(node.right)
        _add_nodes_edges(self.root)
        return Source(dot.source)

# ----------------------
# Demonstração com VALORES FIXOS
# ----------------------
print("=== Árvore com valores fixos ===")
bst_fixed = BinarySearchTree()
valores_fixos = [55, 30, 80, 20, 45, 70, 90]
for v in valores_fixos:
    bst_fixed.insert(v)

# Visualizar a árvore inicial
print("Árvore original:")
display(bst_fixed.visualize())

# Buscar um valor
print("Busca pelo valor 45:", bst_fixed.search(45) is not None)

# Remover um valor
print("Removendo o valor 30...")
bst_fixed.delete(30)
print("Árvore após remoção de 30:")
display(bst_fixed.visualize())

# Inserir novo valor
print("Inserindo novo valor 25...")
bst_fixed.insert(25)
print("Árvore após inserção de 25:")
display(bst_fixed.visualize())

# Altura e profundidade
print("Altura da árvore:", bst_fixed.height())
print("Profundidade do nó 45:", bst_fixed.depth(45))

# ----------------------
# Demonstração com VALORES ALEATÓRIOS
# ----------------------
print("\n=== Árvore com valores aleatórios ===")
bst_random = BinarySearchTree()
valores_random = random.sample(range(1, 201), 15)
print("Valores inseridos:", valores_random)
for v in valores_random:
    bst_random.insert(v)

print("Visualização da árvore aleatória:")
display(bst_random.visualize())

print("Altura da árvore aleatória:", bst_random.height())